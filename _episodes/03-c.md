---
title: "C/C++: Traditional Computing"
teaching: 15
exercises: 15
questions:
- "Why most C is the most influential language in computing?"
objectives:
- "Learn the basics of C and C++"
keypoints:
- "C is widely used, there are well stablished compilers for it, in fact most Operating Systems are written in that language."
- "C++ is a derivative of C with object oriented syntax"
- "C++ can be very powerful for scientific computing when used together with Boost"
---

# C and C++ for Scientific Computing

Both C and C++ are the two most prominent languages for Computer Science, most Operating Systems are written in C. C is also one of the most influential languages in programming, many later languages have borrowed directly or indirectly from C, in particular its syntax, in our set of languages for Scientific Computing, both C++ and Java take a good portion of their syntax from C. That is actually a good thing, because learning C will help a lot moving into those languages if you need to.

Together with Fortran, C and C++ for the `.true.` trinity of High Performance Computing languages. All of them are sufficiently low level to allow very fine degree of optimization and both OpenMP and MPI were created for those languages in mind.
The MPI standard for example, defines the syntax and semantics of a core of library routines useful to a wide range of users writing portable message-passing programs in C, C++, and Fortran. Something similar happens with OpenMP (Open Multi-Processing), an application programming interface (API) that supports multi-platform shared memory multiprocessing programming in C, C++, and Fortran. Any discussion about High Performance Computing programming will be incomplete if no reference were done to those three languages.

Lets talk about C and C++ in this episode together, but remember that each of them has its own standard and even if C++ is often considered to be a superset of C, that is not strictly true. Most C code can easily be made to compile correctly in C++, but there are a few differences that cause some valid C code to be invalid or behave differently in C++. We will not dig into those subtle details. but just be aware that C code is intended to be compiled by a C compiler and C++ code by a C++ compiler.

The GNU Compiler Collection (GCC) offers `gcc` as C compiler and `g++` as the C++ compiler. Similarly, the Intel Compiler Suite offers `icc` for C and `icpc` for C++.

There are several standards for C and C++. Both of them are now ISO standards meaning that the standard is defined by an international organization, not by a specific vendor or company. In the case of C the latest standards are called C99 and and C11. For C++ the latest standards are called C++11 and C++14. All those standards have reach a maturity in implementation from vendors. But be aware as we show in our lesson about modulefiles, that older compilers could not be able to compile code written for example in C++14.

# C Programming Language

Here is presented a simple algorithm for matrix inversion using the GSL library.

~~~
#include <stdio.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_linalg.h>

int main(int argc, const char * argv[])
{
  // Declare pointer variables for a gsl matrix
  gsl_matrix *A, *Ainverse;
  gsl_permutation *p;
  int i, j, s, status, N=4;

  // Create the matrix
  A = gsl_matrix_alloc(N, N);
  Ainverse = gsl_matrix_alloc(N, N);
  p = gsl_permutation_alloc (N);

  for(i=0; i<N; i++) {
      for(j=0; j<N; j++) {
        gsl_matrix_set(A,i,j,drand48());
    }
  }

  // Print the initial matrix
  printf("Initial Matrix\n");
  for (i=0;i<N;i++)
    {
      for (j=0;j<N;j++)
	     {
	        printf("%16.4f ",gsl_matrix_get(A,i,j));
        }
      printf("\n");
    }
  printf("\n");

  status = gsl_linalg_LU_decomp(A, p, &s);
  printf("Status of decomposition %d\n", status);

  status = gsl_linalg_LU_invert (A, p, Ainverse);
  printf("Status of inversion %d\n", status);

  // Print the initial matrix
  printf("Inverse Matrix\n");
  for (i=0;i<N;i++)
    {
      for (j=0;j<N;j++)
	     {
	        printf("%16.4f ",gsl_matrix_get(Ainverse,i,j));
        }
      printf("\n");
    }
  printf("\n");

  // Clean up
  gsl_permutation_free (p);
  gsl_matrix_free(A);
  gsl_matrix_free(Ainverse);

  return 0;
}
~~~
{: .source}

To compile:

~~~
gcc example_gsl.c -lgsl -lgslcblas -lm
~~~


{% include links.md %}
